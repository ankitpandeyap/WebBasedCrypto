package com.robspecs.Cryptography.serviceImpl;

import java.util.HashMap;
import java.util.Map;
import java.util.Base64; // Added for Base64 encoding/decoding of bytes
import java.nio.charset.StandardCharsets; // Added for String to byte[] conversion

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import com.robspecs.Cryptography.service.EncryptionService;

@Service("MONO_ALPHABETIC_CIPHER")
public class MonoAlphabeticCipherService implements EncryptionService {

    private static final Logger logger = LoggerFactory.getLogger(MonoAlphabeticCipherService.class);

    // Define the complete set of characters that this cipher will operate on.
    // This must match the set of characters used in KeyGenerator.generateMonoKey()
    private static final String PLAIN_ALPHABET;

    static {
        String UPPERCASE_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        String LOWERCASE_ALPHABET = "abcdefghijklmnopqrstuvwxyz";
        String NUMBERS = "0123456789";
        // Including common special characters and whitespace, newline, carriage return
        String SPECIAL_CHARACTERS = "!@#$%^&*()_-+={}[]|:;\"'<>,.?/ \r\n";

        PLAIN_ALPHABET = UPPERCASE_ALPHABET + LOWERCASE_ALPHABET + NUMBERS + SPECIAL_CHARACTERS;
        logger.info("MonoAlphabeticCipherService initialized with PLAIN_ALPHABET length: {}", PLAIN_ALPHABET.length());
    }

    /**
     * Creates an encryption map based on the provided passkey (which is the shuffled cipher alphabet).
     *
     * @param passkey The shuffled alphabet string generated by KeyGenerator.generateMonoKey().
     * @return A map from plain character to cipher character.
     */
    private Map<Character, Character> createEncryptMap(String passkey) {
        Map<Character, Character> map = new HashMap<>();
        // The passkey itself is now the shuffled cipher alphabet for the full character set.
        // Ensure the passkey length matches the plain alphabet length.
        if (passkey.length() != PLAIN_ALPHABET.length()) {
            logger.error("Mismatch between PLAIN_ALPHABET length ({}) and passkey length ({}). This indicates a key generation error.",
                    PLAIN_ALPHABET.length(), passkey.length());
            throw new IllegalArgumentException("Invalid passkey for MonoAlphabetic Cipher: length mismatch.");
        }

        for (int i = 0; i < PLAIN_ALPHABET.length(); i++) {
            map.put(PLAIN_ALPHABET.charAt(i), passkey.charAt(i));
        }
        return map;
    }

    /**
     * Creates a decryption map based on the provided passkey (which is the shuffled cipher alphabet).
     *
     * @param passkey The shuffled alphabet string generated by KeyGenerator.generateMonoKey().
     * @return A map from cipher character to plain character.
     */
    private Map<Character, Character> createDecryptMap(String passkey) {
        Map<Character, Character> map = new HashMap<>();
        // Ensure the passkey length matches the plain alphabet length.
        if (passkey.length() != PLAIN_ALPHABET.length()) {
            logger.error("Mismatch between PLAIN_ALPHABET length ({}) and passkey length ({}). This indicates a key generation error.",
                    PLAIN_ALPHABET.length(), passkey.length());
            throw new IllegalArgumentException("Invalid passkey for MonoAlphabetic Cipher: length mismatch.");
        }

        for (int i = 0; i < PLAIN_ALPHABET.length(); i++) {
            // Map from cipher character (from passkey) back to plain character (from PLAIN_ALPHABET)
            map.put(passkey.charAt(i), PLAIN_ALPHABET.charAt(i));
        }
        return map;
    }

    // --- EXISTING STRING METHODS (MODIFIED TO DELEGATE) ---
    @Override
    public String encrypt(String rawMessage, String passkey) throws Exception { // Added throws Exception
        logger.debug("Encrypting text message using MonoAlphabetic Cipher.");
        // Convert string to bytes
        byte[] rawBytes = rawMessage.getBytes(StandardCharsets.UTF_8);
        // Encrypt bytes using the new byte[] method
        byte[] encryptedBytes = encrypt(rawBytes, passkey); // Calls the new byte[] method
        // Convert encrypted bytes back to string for storage (Base64 is common for binary to string)
        return Base64.getEncoder().encodeToString(encryptedBytes); // Base64 encode for string storage
    }

    @Override
    public String decrypt(String encryptedMessage, String passkey) throws Exception { // Added throws Exception
        logger.debug("Decrypting text message using MonoAlphabetic Cipher.");
        // Decode Base64 string to bytes
        byte[] encryptedBytes = Base64.getDecoder().decode(encryptedMessage);
        // Decrypt bytes using the new byte[] method
        byte[] decryptedBytes = decrypt(encryptedBytes, passkey); // Calls the new byte[] method
        // Convert decrypted bytes back to string
        return new String(decryptedBytes, StandardCharsets.UTF_8);
    }
    // --- END MODIFIED EXISTING STRING METHODS ---


    // --- NEW METHODS FOR BINARY DATA (FILES) ---
    @Override
    public byte[] encrypt(byte[] rawBytes, String keyString) throws Exception {
        logger.debug("Encrypting {} bytes of binary data using MonoAlphabetic Cipher.", rawBytes.length);
        Map<Character, Character> encryptMap = createEncryptMap(keyString); // Use the provided keyString as the alphabet map
        byte[] encrypted = new byte[rawBytes.length];

        for (int i = 0; i < rawBytes.length; i++) {
            // Treat each byte as a character (carefully handling byte range for char conversion)
            char ch = (char) (rawBytes[i] & 0xFF); // Convert byte to unsigned char value
            
            // Apply the substitution. If character not in alphabet, it passes through.
            if (encryptMap.containsKey(Character.valueOf(ch))) {
                encrypted[i] = (byte) encryptMap.get(Character.valueOf(ch)).charValue();
            } else {
                encrypted[i] = rawBytes[i]; // Pass through unchanged
                logger.warn("Byte value '{}' (char '{}') not found in PLAIN_ALPHABET. Passing through unchanged.", rawBytes[i], ch);
            }
        }
        logger.debug("Binary data encryption complete. Encrypted size: {} bytes.", encrypted.length);
        return encrypted;
    }

    @Override
    public byte[] decrypt(byte[] encryptedBytes, String keyString) throws Exception {
        logger.debug("Decrypting {} bytes of binary data using MonoAlphabetic Cipher.", encryptedBytes.length);
        Map<Character, Character> decryptMap = createDecryptMap(keyString); // Use the provided keyString as the alphabet map
        byte[] decrypted = new byte[encryptedBytes.length];

        for (int i = 0; i < encryptedBytes.length; i++) {
            // Treat each byte as a character
            char ch = (char) (encryptedBytes[i] & 0xFF); // Convert byte to unsigned char value

            // Apply the inverse substitution. If character not in alphabet, it passes through.
            if (decryptMap.containsKey(Character.valueOf(ch))) {
                decrypted[i] = (byte) decryptMap.get(Character.valueOf(ch)).charValue();
            } else {
                decrypted[i] = encryptedBytes[i]; // Pass through unchanged
                logger.warn("Byte value '{}' (char '{}') not found in PLAIN_ALPHABET. Passing through unchanged.", encryptedBytes[i], ch);
            }
        }
        logger.debug("Binary data decryption complete. Decrypted size: {} bytes.", decrypted.length);
        return decrypted;
    }
    // --- END NEW METHODS ---
}