package com.robspecs.Cryptography.serviceImpl;

import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import com.robspecs.Cryptography.service.EncryptionService;

@Service("MONO_ALPHABETIC_CIPHER")
public class MonoAlphabeticCipherService implements EncryptionService {

    private static final Logger logger = LoggerFactory.getLogger(MonoAlphabeticCipherService.class);

    // Define the complete set of characters that this cipher will operate on.
    // This must match the set of characters used in KeyGenerator.generateMonoKey()
    private static final String PLAIN_ALPHABET;

    static {
        String UPPERCASE_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        String LOWERCASE_ALPHABET = "abcdefghijklmnopqrstuvwxyz";
        String NUMBERS = "0123456789";
        // Including common special characters and whitespace, newline, carriage return
        String SPECIAL_CHARACTERS = "!@#$%^&*()_-+={}[]|:;\"'<>,.?/ \r\n";

        PLAIN_ALPHABET = UPPERCASE_ALPHABET + LOWERCASE_ALPHABET + NUMBERS + SPECIAL_CHARACTERS;
        logger.info("MonoAlphabeticCipherService initialized with PLAIN_ALPHABET length: {}", PLAIN_ALPHABET.length());
    }

    /**
     * Creates an encryption map based on the provided passkey (which is the shuffled cipher alphabet).
     *
     * @param passkey The shuffled alphabet string generated by KeyGenerator.generateMonoKey().
     * @return A map from plain character to cipher character.
     */
    private Map<Character, Character> createEncryptMap(String passkey) {
        Map<Character, Character> map = new HashMap<>();
        // The passkey itself is now the shuffled cipher alphabet for the full character set.
        // Ensure the passkey length matches the plain alphabet length.
        if (passkey.length() != PLAIN_ALPHABET.length()) {
            logger.error("Mismatch between PLAIN_ALPHABET length ({}) and passkey length ({}). This indicates a key generation error.",
                    PLAIN_ALPHABET.length(), passkey.length());
            throw new IllegalArgumentException("Invalid passkey for MonoAlphabetic Cipher: length mismatch.");
        }

        for (int i = 0; i < PLAIN_ALPHABET.length(); i++) {
            map.put(PLAIN_ALPHABET.charAt(i), passkey.charAt(i));
        }
        return map;
    }

    /**
     * Creates a decryption map based on the provided passkey (which is the shuffled cipher alphabet).
     *
     * @param passkey The shuffled alphabet string generated by KeyGenerator.generateMonoKey().
     * @return A map from cipher character to plain character.
     */
    private Map<Character, Character> createDecryptMap(String passkey) {
        Map<Character, Character> map = new HashMap<>();
        // Ensure the passkey length matches the plain alphabet length.
        if (passkey.length() != PLAIN_ALPHABET.length()) {
            logger.error("Mismatch between PLAIN_ALPHABET length ({}) and passkey length ({}). This indicates a key generation error.",
                    PLAIN_ALPHABET.length(), passkey.length());
            throw new IllegalArgumentException("Invalid passkey for MonoAlphabetic Cipher: length mismatch.");
        }

        for (int i = 0; i < PLAIN_ALPHABET.length(); i++) {
            // Map from cipher character (from passkey) back to plain character (from PLAIN_ALPHABET)
            map.put(passkey.charAt(i), PLAIN_ALPHABET.charAt(i));
        }
        return map;
    }

    @Override
    public String encrypt(String rawMessage, String passkey) {
        logger.debug("Encrypting message using MonoAlphabetic Cipher with key (length: {}).", passkey.length());
        Map<Character, Character> encryptMap = createEncryptMap(passkey);
        StringBuilder encrypted = new StringBuilder();
        for (char ch : rawMessage.toCharArray()) {
            // Use Character.valueOf() to handle potential auto-boxing issues with map keys
            if (encryptMap.containsKey(Character.valueOf(ch))) {
                encrypted.append(encryptMap.get(Character.valueOf(ch)));
            } else {
                // If a character is not in our defined PLAIN_ALPHABET, it passes through unchanged.
                // This is a design choice for simple monoalphabetic ciphers.
                encrypted.append(ch);
                logger.warn("Character '{}' not found in PLAIN_ALPHABET. Passing through unchanged.", ch);
            }
        }
        String encryptedMessage = encrypted.toString();
        logger.debug("Message encrypted successfully");
        return encryptedMessage;
    }

    @Override
    public String decrypt(String encryptedMessage, String passkey) {
        logger.debug("Decrypting message using MonoAlphabetic Cipher with key (length: {}).", passkey.length());
        Map<Character, Character> decryptMap = createDecryptMap(passkey);
        StringBuilder decrypted = new StringBuilder();
        for (char ch : encryptedMessage.toCharArray()) {
            // Use Character.valueOf() to handle potential auto-boxing issues with map keys
            if (decryptMap.containsKey(Character.valueOf(ch))) {
                decrypted.append(decryptMap.get(Character.valueOf(ch)));
            } else {
                // If a character is not in our defined PLAIN_ALPHABET, it passes through unchanged.
                decrypted.append(ch);
                logger.warn("Character '{}' not found in PLAIN_ALPHABET. Passing through unchanged.", ch);
            }
        }
        String decryptedMessage = decrypted.toString();
        logger.debug("Message decrypted successfully");
        return decryptedMessage;
    }
}
